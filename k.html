<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kashif Chatbot</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Custom scrollbar for better appearance */
        #chat-container::-webkit-scrollbar {
            width: 8px;
        }
        #chat-container::-webkit-scrollbar-thumb {
            background-color: #cbd5e1; /* slate-300 */
            border-radius: 4px;
        }
        #chat-container::-webkit-scrollbar-track {
            background-color: #f1f5f9; /* slate-100 */
        }
        body {
            font-family: 'Inter', sans-serif;
            height: 100vh;
            margin: 0;
            display: flex;
            flex-direction: column;
            background-color: #f8fafc; /* neutral white-ish background */
        }
        /* Ensure the main chat area takes up available space */
        .main-content {
            flex-grow: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        /* Style for the stop reading button when audio is playing */
        .tts-button[data-state="playing"] {
            color: #ef4444; /* red-500 */
        }
        .tts-button[data-state="playing"] svg {
            color: #ef4444; /* red-500 */
        }
        
    </style>
</head>
<body>

    <!-- Header -->
    <header class="p-4 bg-white shadow-md flex justify-center items-center">
        <h1 class="text-xl font-bold text-gray-800 flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 text-indigo-500 mr-2"><path d="M12 20a8 8 0 1 0 0-16 8 8 0 0 0 0 16Z"/><path d="M12 10V18"/><path d="M12 12V18"/></svg>
         Kashif
        </h1>
    </header>

    <!-- Chat Container -->
    <div id="chat-container" class="main-content p-4 overflow-y-auto space-y-4">
        <!-- Initial welcome message -->
        <div class="flex justify-start">
            <div class="bg-indigo-100 text-indigo-800 p-3 rounded-xl rounded-tl-none max-w-xs md:max-w-md shadow-sm">
                <p class="font-semibold text-sm">Kashif</p>
                <p class="text-sm">Hello! I'm Kashif. How I Can help you. Try sending me a picture!</p>
            </div>
        </div>
        <!-- Messages will be injected here -->
    </div>

    <!-- Input Form (Fixed to Bottom) -->
    <div class="sticky bottom-0 bg-white border-t border-gray-200 p-4 shadow-xl">
        <div class="max-w-3xl mx-auto">
            
            <!-- Image Preview Area -->
            <div id="image-preview-container" class="mb-3 hidden">
                <div class="relative inline-block border border-gray-300 rounded-lg p-2 bg-gray-50">
                    <img id="image-preview" class="h-16 w-16 object-cover rounded-md" alt="Image Preview">
                    <button type="button" id="remove-image" title="Remove Image" class="absolute top-0 right-0 -mt-2 -mr-2 bg-red-500 text-white rounded-full p-0.5 shadow-md hover:bg-red-600 transition duration-150">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </button>
                </div>
            </div>

            <div id="loading-indicator" class="text-center mb-2 hidden">
                <span class="text-sm text-indigo-500 flex items-center justify-center">
                    <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    Kashif answering you...
                </span>
            </div>
            <form id="chat-form" class="flex space-x-2">
                <!-- Hidden File Input -->
                <input type="file" id="image-input" accept="image/*" class="hidden">
                
                <!-- File Upload Button (Paperclip) -->
                <button type="button" id="upload-button" title="Upload Image" class="flex-shrink-0 bg-gray-200 hover:bg-indigo-100 text-indigo-600 p-3 rounded-xl transition duration-150 shadow-md">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19A4 4 0 0 1 18.9 4.1l-9.19 9.19a2 2 0 0 0 2.83 2.83l9.19-9.19"/></svg>
                </button>
                
                <input
                    type="text"
                    id="user-input"
                    placeholder="Type your message or ask about the image..."
                    required
                    autocomplete="off"
                    class="flex-grow p-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 shadow-inner"
                >
                <button
                    type="submit"
                    id="send-button"
                    class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-4 rounded-xl transition duration-150 shadow-md flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><path d="M22 2L11 13"/><path d="M22 2L15 22 11 13 2 9 22 2Z"/></svg>
                </button>
            </form>
            <p class="text-xs text-center text-gray-400 mt-2">Powered by Kashif Khan</p>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const MODEL = 'gemini-2.5-flash-preview-09-2025';
        const AUDIO_MODEL = 'gemini-2.5-flash-preview-tts';
        const VOICE_NAME = 'Charon'; // A clear, informative voice
        const apiKey = "AIzaSyDroFVeOW8j9FZ4ixXpjQI23YJwH7MLQZs"; // Canvas will automatically populate this during runtime
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=${apiKey}`;

        // --- DOM Elements ---
        const chatForm = document.getElementById('chat-form');
        const userInput = document.getElementById('user-input');
        const chatContainer = document.getElementById('chat-container');
        const loadingIndicator = document.getElementById('loading-indicator');
        const sendButton = document.getElementById('send-button');
        const imageInput = document.getElementById('image-input');
        const uploadButton = document.getElementById('upload-button');
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const imagePreview = document.getElementById('image-preview');
        const removeImageButton = document.getElementById('remove-image');

        // --- State Management ---
        let chatHistory = [];
        let isGenerating = false;
        let selectedImageBase64 = null;
        let selectedImageMimeType = null;
        let currentAudio = null; // To track and stop currently playing audio

        // --- Utility Functions: Audio Helpers (PCM to WAV conversion) ---

        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function pcmToWav(pcm16, sampleRate = 24000) {
            const numChannels = 1;
            const bytesPerSample = 2; // 16-bit PCM

            // Create WAV header
            const buffer = new ArrayBuffer(44 + pcm16.length * bytesPerSample);
            const view = new DataView(buffer);
            let offset = 0;

            // RIFF chunk descriptor
            writeString(view, offset, 'RIFF'); offset += 4;
            view.setUint32(offset, 36 + pcm16.length * bytesPerSample, true); offset += 4; // ChunkSize
            writeString(view, offset, 'WAVE'); offset += 4;

            // fmt sub-chunk
            writeString(view, offset, 'fmt '); offset += 4;
            view.setUint32(offset, 16, true); offset += 4;             // Subchunk1Size (16 for PCM)
            view.setUint16(offset, 1, true); offset += 2;              // AudioFormat (1 for PCM)
            view.setUint16(offset, numChannels, true); offset += 2;    // NumChannels
            view.setUint32(offset, sampleRate, true); offset += 4;     // SampleRate
            view.setUint32(offset, sampleRate * numChannels * bytesPerSample, true); offset += 4; // ByteRate
            view.setUint16(offset, numChannels * bytesPerSample, true); offset += 2;    // BlockAlign
            view.setUint16(offset, 8 * bytesPerSample, true); offset += 2;              // BitsPerSample (16)

            // data sub-chunk
            writeString(view, offset, 'data'); offset += 4;
            view.setUint32(offset, pcm16.length * bytesPerSample, true); offset += 4; // Subchunk2Size

            // Write PCM data
            const pcmArray = new Uint8Array(buffer, offset);
            const pcmData = new Uint8Array(pcm16.buffer);
            pcmArray.set(pcmData);

            return new Blob([buffer], { type: 'audio/wav' });
        }


        /**
         * Simple markdown-to-HTML conversion for model output (basic bold/italics/newlines)
         * @param {string} text
         * @returns {string} HTML formatted text
         */
        function formatModelText(text) {
            // Newlines to <br>
            let htmlText = text.replace(/\n/g, '<br>');
            // Bold (**text** or __text__)
            htmlText = htmlText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            htmlText = htmlText.replace(/__(.*?)__/g, '<strong>$1</strong>');
            // Italics (*text* or _text_)
            htmlText = htmlText.replace(/\*(.*?)\*/g, '<em>$1</em>');
            htmlText = htmlText.replace(/_(.*?)_/g, '<em>$1</em>');
            return htmlText;
        }


        // --- Utility Functions: API & Error Handling ---

        /**
         * Implements exponential backoff for API calls.
         */
        async function backoffFetch(url, options, retries = 0) {
            const MAX_RETRIES = 5;
            try {
                const response = await fetch(url, options);
                if (!response.ok && response.status === 429 && retries < MAX_RETRIES) {
                    const delay = Math.pow(2, retries) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return backoffFetch(url, options, retries + 1);
                }
                if (!response.ok) {
                    // Check for general API errors
                    try {
                        const errorBody = await response.json();
                        throw new Error(`API Error ${response.status}: ${errorBody.error?.message || response.statusText}`);
                    } catch {
                        throw new Error(`API error: ${response.status} ${response.statusText}`);
                    }
                }
                return response;
            } catch (error) {
                if (retries < MAX_RETRIES) {
                    const delay = Math.pow(2, retries) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return backoffFetch(url, options, retries + 1);
                }
                throw new Error("Failed to fetch response after multiple retries.");
            }
        }

        // --- TTS Generation ---

        async function generateAudio(text) {
            const audioApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${AUDIO_MODEL}:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{
                    parts: [{ text: text }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: VOICE_NAME }
                        }
                    }
                },
                model: AUDIO_MODEL
            };

            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            const response = await backoffFetch(audioApiUrl, options);
            const result = await response.json();

            const part = result?.candidates?.[0]?.content?.parts?.[0];
            const audioData = part?.inlineData?.data;
            const mimeType = part?.inlineData?.mimeType; 

            if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 24000;

                const pcmData = base64ToArrayBuffer(audioData);
                // API returns signed PCM16 audio data.
                const pcm16 = new Int16Array(pcmData.slice(0, pcmData.byteLength - (pcmData.byteLength % 2)));
                const wavBlob = pcmToWav(pcm16, sampleRate);

                return wavBlob;
            } else {
                console.error("TTS API response missing valid audio data:", result);
                throw new Error("TTS output failed to generate audio data.");
            }
        }


        // --- UI Rendering Functions ---

        /**
         * Renders a message bubble to the chat container.
         * @param {string} text - The message content.
         * @param {'user' | 'model' | 'loading' | 'error'} role - The sender of the message.
         * @param {string | null} imageUrl - Data URL of the image sent by the user.
         * @returns {HTMLElement} The created message element.
         */
        function renderMessage(text, role, imageUrl = null) {
            const messageWrapper = document.createElement('div');
            const contentContainer = document.createElement('div');
            const textBubble = document.createElement('div');

            let wrapperClasses = 'flex';
            let bubbleClasses = 'p-3 rounded-xl shadow-sm text-sm break-words';
            const maxWidth = 'max-w-xs md:max-w-md';

            if (role === 'user') {
                wrapperClasses += ' justify-end';
                bubbleClasses += ' bg-indigo-500 text-white rounded-br-none';
            } else if (role === 'model') {
                wrapperClasses += ' justify-start';
                bubbleClasses += ' bg-indigo-100 text-gray-800 rounded-tl-none';
            } else if (role === 'loading') {
                wrapperClasses += ' justify-start';
                bubbleClasses += ' bg-gray-200 text-gray-600 rounded-tl-none animate-pulse';
            } else if (role === 'error') {
                wrapperClasses += ' justify-start';
                bubbleClasses += ' bg-red-100 text-red-700 rounded-tl-none';
            }

            messageWrapper.className = wrapperClasses;
            contentContainer.className = `flex flex-col space-y-2 ${maxWidth}`;
            
            // 1. Add Image if available (only for user messages)
            if (imageUrl && role === 'user') {
                const imageElement = document.createElement('img');
                imageElement.src = imageUrl;
                imageElement.className = 'w-full h-auto max-h-48 object-cover rounded-xl shadow-md';
                contentContainer.appendChild(imageElement);
            }

            // 2. Add Text Bubble
            textBubble.className = bubbleClasses;
            textBubble.innerHTML = role === 'model' ? formatModelText(text) : text;
            contentContainer.appendChild(textBubble);

            // 3. Add TTS Button (only for model messages, if there is text to read)
            if (role === 'model' && text.trim().length > 0) {
                const audioButton = document.createElement('button');
                audioButton.className = 'tts-button flex items-center text-xs text-gray-500 hover:text-indigo-600 transition duration-150 mt-1 disabled:opacity-50';
                audioButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4 mr-1">
                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a6.1 6.1 0 0 1 0 7.08"></path>
                    </svg>
                    Read Aloud
                `;
                audioButton.onclick = (e) => handleReadAloud(e, text);
                
                contentContainer.appendChild(audioButton);
            }

            messageWrapper.appendChild(contentContainer);

            // Append to container and scroll to bottom
            chatContainer.appendChild(messageWrapper);
            chatContainer.scrollTop = chatContainer.scrollHeight;

            return messageWrapper;
        }


        // --- Core Handlers ---

        /**
         * Clears the image preview and state.
         */
        function clearImageInput() {
            selectedImageBase64 = null;
            selectedImageMimeType = null;
            imageInput.value = ''; 
            imagePreviewContainer.classList.add('hidden');
            imagePreview.src = '';
        }

        /**
         * Handles image file selection and conversion to Base64.
         */
        function handleImageSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                clearImageInput();
                return;
            }

            if (!file.type.startsWith('image/')) {
                console.error("Selected file is not an image.");
                // Using a simple notification message instead of alert()
                renderMessage("Please select an image file.", 'error'); 
                clearImageInput();
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const dataUrl = e.target.result;
                const base64Data = dataUrl.split(',')[1];

                selectedImageBase64 = base64Data;
                selectedImageMimeType = file.type;

                imagePreview.src = dataUrl;
                imagePreviewContainer.classList.remove('hidden');
            };
            reader.onerror = (error) => {
                console.error("Error reading file:", error);
                renderMessage("Failed to load image. Try a different file.", 'error');
                clearImageInput();
            };
            reader.readAsDataURL(file);
        }

        /**
         * Handles TTS button click to generate and play audio.
         */
        async function handleReadAloud(event, text) {
            const button = event.currentTarget;
            const originalText = button.innerHTML;
            
            // Stop any currently playing audio
            if (currentAudio) {
                currentAudio.pause();
                URL.revokeObjectURL(currentAudio.src);
                currentAudio = null;

                // Reset all other buttons
                document.querySelectorAll('.tts-button').forEach(btn => {
                    if (btn !== button && btn.dataset.state === 'playing') {
                        btn.dataset.state = 'paused';
                        btn.innerHTML = originalText;
                    }
                });
            }

            // Simple toggle: If this button was just playing, clicking it stops it.
            if (button.dataset.state === 'playing') {
                button.dataset.state = 'paused';
                button.innerHTML = originalText;
                return;
            }

            // Indicate loading
            button.disabled = true;
            button.innerHTML = `
                <svg class="animate-spin -ml-1 mr-1 h-4 w-4 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Generating...
            `;

            try {
                const audioBlob = await generateAudio(text);
                const audioUrl = URL.createObjectURL(audioBlob);
                
                const audio = new Audio(audioUrl);
                currentAudio = audio;

                // Set state to playing and update button icon
                button.dataset.state = 'playing';
                button.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4 mr-1">
                        <rect x="3" y="10" width="18" height="4" fill="currentColor" stroke="none"></rect>
                    </svg>
                    Stop Reading
                `;

                audio.play();

                audio.onended = () => {
                    // Cleanup state and URL when done
                    button.dataset.state = 'finished';
                    button.innerHTML = originalText;
                    button.disabled = false;
                    URL.revokeObjectURL(audioUrl);
                    currentAudio = null;
                };

            } catch (error) {
                console.error("Audio playback error:", error);
                button.innerHTML = `
                    <span class="text-red-500 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4 mr-1"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>
                        Error
                    </span>
                `;
                // Re-enable after a short delay
                setTimeout(() => { button.innerHTML = originalText; button.disabled = false; }, 3000);
            }
        }

        /**
         * Calls the Gemini API to get a response (supports multimodal).
         */
        async function generateResponse() {
            // The payload uses the entire chatHistory for context, which includes the latest user message (and its image)
            const payload = {
                contents: chatHistory,
            };

            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            try {
                const response = await backoffFetch(apiUrl, options);
                const result = await response.json();

                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (!text) {
                    console.error("API response missing text content:", result);
                    // Check if model refused to respond
                    const safetyRatings = result.candidates?.[0]?.safetyRatings;
                    if (safetyRatings && safetyRatings.some(r => r.probability !== 'NEGLIGIBLE')) {
                         return "I can't respond to that query due to safety policy limitations.";
                    }
                    return "Sorry, I couldn't generate a response. The API returned an empty or invalid response.";
                }

                return text;

            } catch (error) {
                console.error('Gemini API Error:', error);
                throw error;
            }
        }


        /**
         * Main function to handle user message, image, and trigger API call.
         */
        async function sendMessage(e) {
            e.preventDefault();

            if (isGenerating) return;

            const userText = userInput.value.trim();
            if (userText === '' && !selectedImageBase64) return;

            // Capture current image state
            const currentImageBase64 = selectedImageBase64;
            const currentImageMimeType = selectedImageMimeType;
            const currentImageUrl = currentImageBase64 ? imagePreview.src : null;
            
            // Text to display for the user
            const displayUserText = userText || '*(Image Sent)*';

            // 1. Disable input and set generating state, clear input fields
            isGenerating = true;
            userInput.value = '';
            userInput.disabled = true;
            sendButton.disabled = true;
            clearImageInput(); // Clear image state immediately
            loadingIndicator.classList.remove('hidden');

            // 2. Add user message (with image data) to history
            let userParts = [];
            if (currentImageBase64) {
                userParts.push({ inlineData: { mimeType: currentImageMimeType, data: currentImageBase64 } });
            }
            if (userText) {
                userParts.push({ text: userText });
            }
            // Always push to history first, as the API call uses chatHistory
            chatHistory.push({ role: 'user', parts: userParts });

            // 3. Render user message (displaying image)
            renderMessage(displayUserText, 'user', currentImageUrl);

            // 4. Render loading message
            const loadingElement = renderMessage('...', 'loading');

            try {
                // 5. Call API
                const modelResponseText = await generateResponse();

                // 6. Update history and UI
                chatHistory.push({ role: 'model', parts: [{ text: modelResponseText }] });

                loadingElement.remove();
                renderMessage(modelResponseText, 'model');

            } catch (error) {
                loadingElement.remove();
                renderMessage(`An unexpected error occurred: ${error.message}`, 'error');
            } finally {
                // 7. Re-enable input and reset state
                isGenerating = false;
                userInput.disabled = false;
                sendButton.disabled = false;
                loadingIndicator.classList.add('hidden');
                userInput.focus();
            }
        }

        // --- Event Listeners ---
        chatForm.addEventListener('submit', sendMessage);
        uploadButton.addEventListener('click', () => imageInput.click());
        imageInput.addEventListener('change', handleImageSelect);
        removeImageButton.addEventListener('click', clearImageInput);

        // Optional: Auto-focus the input on load
        window.onload = () => {
             userInput.focus();
        }
    </script>

</body>
</html>